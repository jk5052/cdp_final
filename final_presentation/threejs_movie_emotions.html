<!DOCTYPE html>
<html lang="ko">
<head>
    <title>3D Movie Emotion Universe</title>
    <meta charset="utf-8">
    <style>
        * {
            margin: 0 !important;
            padding: 0 !important;
            box-sizing: border-box !important;
        }

        html {
            width: 100vw !important;
            height: 100vh !important;
            overflow: hidden !important;
        }

        body {
            width: 100vw !important;
            height: 100vh !important;
            font-family: 'Arial', sans-serif;
            background: #000000 !important;
            color: white;
            overflow: hidden !important;
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
        }

        canvas {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            max-width: 100vw !important;
            max-height: 100vh !important;
            display: block !important;
            z-index: 1 !important;
            object-fit: cover !important;
        }
        
        .ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #333;
            max-width: 320px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        
        .movie-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #444;
            max-width: 400px;
            z-index: 100;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.4s ease;
        }
        
        .movie-info.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
        }
        
        .controls button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #666;
            color: white;
            padding: 10px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }
        
        .controls button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        
        .speed-control {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
        }
        
        .speed-slider {
            width: 150px;
            margin: 0 10px;
        }
        
        .legend {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
            font-size: 12px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .container {
            width: 100vw;
            height: 100vh;
            background: transparent;
            border-radius: 0;
            box-shadow: none;
            border: none;
            position: fixed;
            top: 0;
            left: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div class="ui-panel">
        <h2>üåå 3D Movie Emotion Universe</h2>
        <p><strong>2000 Movies with 30 Emotion Layers</strong></p>
        <p><strong>Navigation:</strong></p>
        <p>üñ±Ô∏è Drag: Look around</p>
        <p>üéµ Click: Play emotion sound</p>
        <p>üéØ Double-click: Zoom to movie</p>
        <p>üé° Wheel: Zoom in/out</p>
        <p><strong>3D Mapping:</strong></p>
        <p>X: Warmth-Coldness | Y: Heavy-Light | Z: Bright-Dark</p>
    </div>

    <div class="controls">
        <button onclick="resetCamera()">üéØ Reset View</button>
        <button onclick="randomFocus()">üöÄ Random Movie</button>
        <button onclick="toggleAnimation()">‚è∏Ô∏è Animation</button>
        <button onclick="toggleAutoRotate()">üîÑ Auto Rotate</button>
    </div>

    <div class="movie-info" id="movieInfo">
        <h3 id="movieTitle"></h3>
        <p id="movieDetails"></p>
        <p id="movieMessage"></p>
        <div id="emotionProfile"></div>
    </div>

    <div class="speed-control">
        <label>Speed: </label>
        <input type="range" class="speed-slider" min="0" max="20" value="5"
               oninput="updateSpeed(this.value)">
        <span id="speedValue">5</span>
    </div>

    <div class="legend">
        <h4>Color Coding</h4>
        <div style="color: #ff6b35;">üî• Warm Movies</div>
        <div style="color: #4a90e2;">‚ùÑÔ∏è Cold Movies</div>
        <div style="color: #9b59b6;">üåë Dark Movies</div>
        <div style="color: #f1c40f;">‚ú® Bright Movies</div>
        <div style="color: #95a5a6;">‚ö™ Neutral Movies</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    
    <script>
        // Í∏ÄÎ°úÎ≤å Î≥ÄÏàò
        let camera, scene, renderer, controls;
        let mouseX = 0, mouseY = 0;
        let particles = [];
        let movieParticles = [];
        let isAnimating = true;
        let autoRotate = false;
        let speed = 5;
        let time = 0;
        
        // ÌÅ¥Î¶≠ Í¥ÄÎ†® Î≥ÄÏàò
        let clickTimeout = null;
        let clickCount = 0;
        let lastClickedParticle = null;
        
        // Tone.js ÏÑ§Ï†ï
        let audioInitialized = false;
        let textureSynths = {};
        let currentlyPlaying = null;
        let activeSounds = [];

        // ÏòÅÌôî ÏÉòÌîå Îç∞Ïù¥ÌÑ∞
        let movieData = [
            {
                title: "GoodFellas", country: "US", year: 1990,
                director: "Martin Scorsese", genres: ["Drama", "Crime"],
                core_message: "The allure and disillusionment of criminal lifestyle",
                textures: { 
                    warmth: 0.3, heaviness: 0.7, chaos: 0.8, tenderness: 0.2, darkness: 0.7, 
                    luminosity: 0.3, density: 0.6, emptiness: 0.4, harshness: 0.8, flowing: 0.4,
                    coldness: 0.7, lightness: 0.3, solidity: 0.5, fragility: 0.5, weight: 0.6,
                    buoyancy: 0.4, burning: 0.5, freezing: 0.5, smoothness: 0.3, roughness: 0.7,
                    stagnation: 0.6, pulsing: 0.5, stillness: 0.4, acceleration: 0.6, deceleration: 0.4,
                    rhythm: 0.5, transparency: 0.4, opacity: 0.6, clarity: 0.5, murkiness: 0.6
                }
            },
            {
                title: "Edward Scissorhands", country: "US", year: 1990,
                director: "Tim Burton", genres: ["Fantasy", "Drama"],
                core_message: "Acceptance and beauty of individuality",
                textures: {
                    warmth: 0.7, heaviness: 0.4, chaos: 0.3, tenderness: 0.8, darkness: 0.3,
                    luminosity: 0.7, density: 0.5, emptiness: 0.3, harshness: 0.2, flowing: 0.6,
                    coldness: 0.3, lightness: 0.6, solidity: 0.5, fragility: 0.5, weight: 0.4,
                    buoyancy: 0.6, burning: 0.5, freezing: 0.5, smoothness: 0.7, roughness: 0.3,
                    stagnation: 0.4, pulsing: 0.5, stillness: 0.5, acceleration: 0.5, deceleration: 0.5,
                    rhythm: 0.5, transparency: 0.6, opacity: 0.4, clarity: 0.6, murkiness: 0.4
                }
            },
            {
                title: "The Silence of the Lambs", country: "US", year: 1991,
                director: "Jonathan Demme", genres: ["Crime", "Thriller"],
                core_message: "The thin line between civilization and savagery",
                textures: {
                    warmth: 0.2, heaviness: 0.8, chaos: 0.6, tenderness: 0.1, darkness: 0.9,
                    luminosity: 0.2, density: 0.7, emptiness: 0.3, harshness: 0.9, flowing: 0.3,
                    coldness: 0.8, lightness: 0.2, solidity: 0.6, fragility: 0.4, weight: 0.8,
                    buoyancy: 0.2, burning: 0.5, freezing: 0.5, smoothness: 0.2, roughness: 0.8,
                    stagnation: 0.7, pulsing: 0.5, stillness: 0.3, acceleration: 0.7, deceleration: 0.3,
                    rhythm: 0.5, transparency: 0.3, opacity: 0.7, clarity: 0.4, murkiness: 0.8
                }
            }
        ];

        // 2000Í∞ú ÏòÅÌôî Îç∞Ïù¥ÌÑ∞ Î°úÎìú
        async function loadMovieData() {
            try {
                console.log('üåê Loading 2000 movie data from local JSON...');

                // public Ìè¥ÎçîÏùò 2000Í∞ú ÏòÅÌôî Îç∞Ïù¥ÌÑ∞ Î°úÎìú
                const response = await fetch('../public/message_based_emotion_data_2025-08-04.json');

                if (!response.ok) throw new Error(`JSON load error! status: ${response.status}`);

                const data = await response.json();
                const processedData = data.map(movie => ({
                    title: movie.basic_info.title,
                    country: movie.basic_info.country,
                    year: movie.basic_info.year,
                    director: movie.basic_info.director,
                    genres: movie.basic_info.genres,
                    core_message: movie.basic_info.core_message,
                    vote_average: movie.basic_info.vote_average,
                    textures: movie.emotion_layers.layer1_message_based // 30Í∞ú Í∞êÏ†ï ÌÖçÏä§Ï≤ò ÏÇ¨Ïö©
                }));

                console.log(`‚úÖ Loaded ${processedData.length} movies from local JSON`);
                return processedData;

            } catch (error) {
                console.error('‚ùå Failed to load local JSON data:', error);
                console.log('üìù Using sample data instead');
                return movieData;
            }
        }

        // 30Í∞ú ÌÖçÏä§Ï≤ò Ïã†Ïä§ ÏÉùÏÑ±
        function createTextureSynths() {
            const reverb = new Tone.Reverb({ roomSize: 0.8, decay: 4 }).toDestination();
            const distortion = new Tone.Distortion(0.4).toDestination();
            const filter = new Tone.Filter({ frequency: 2000, type: "lowpass" }).toDestination();
            
            textureSynths = {
                // Ï°¥Ïû¨Í∞ê/Î¨¥Í≤å
                heaviness: new Tone.MonoSynth({ oscillator: { type: "sawtooth" } }).toDestination(),
                lightness: new Tone.Synth({ oscillator: { type: "sine" } }).toDestination(),
                density: new Tone.PolySynth(Tone.Synth, { maxPolyphony: 8 }).toDestination(),
                emptiness: new Tone.Synth().connect(reverb),
                solidity: new Tone.MonoSynth({ oscillator: { type: "square" } }).toDestination(),
                fragility: new Tone.Synth({ envelope: { attack: 0.3 } }).toDestination(),
                weight: new Tone.FMSynth().toDestination(),
                buoyancy: new Tone.Synth({ oscillator: { type: "sine" } }).toDestination(),

                // Ïò®ÎèÑ/Ï¥âÍ∞ê
                warmth: new Tone.PolySynth(Tone.Synth).toDestination(),
                coldness: new Tone.MonoSynth({ oscillator: { type: "triangle" } }).toDestination(),
                burning: new Tone.MonoSynth().connect(distortion),
                freezing: new Tone.Synth().connect(reverb),
                tenderness: new Tone.Synth().connect(filter),
                harshness: new Tone.MonoSynth().connect(distortion),
                smoothness: new Tone.Synth().connect(filter),
                roughness: new Tone.MonoSynth({ oscillator: { type: "sawtooth" } }).toDestination(),

                // ÏõÄÏßÅÏûÑ/Î¶¨Îì¨
                flowing: new Tone.Synth().toDestination(),
                stagnation: new Tone.MonoSynth().toDestination(),
                pulsing: new Tone.Synth().toDestination(),
                stillness: new Tone.Synth({ envelope: { attack: 2.0 } }).toDestination(),
                acceleration: new Tone.Synth().toDestination(),
                deceleration: new Tone.Synth().toDestination(),
                rhythm: new Tone.MembraneSynth().toDestination(),
                chaos: new Tone.NoiseSynth({ noise: { type: "brown" } }).toDestination(),

                // Îπõ/Ïñ¥Îë†/Ìà¨Î™ÖÎèÑ
                luminosity: new Tone.Synth().toDestination(),
                darkness: new Tone.MonoSynth().toDestination(),
                transparency: new Tone.Synth().connect(reverb),
                opacity: new Tone.PolySynth(Tone.Synth).toDestination(),
                clarity: new Tone.Synth().toDestination(),
                murkiness: new Tone.FMSynth().toDestination()
            };
            
            Object.values(textureSynths).forEach(synth => {
                if (synth.volume) synth.volume.value = -20;
            });
        }

        // Tone.js Ï¥àÍ∏∞Ìôî
        async function initAudio() {
            if (audioInitialized) return;
            await Tone.start();
            createTextureSynths();
            audioInitialized = true;
            console.log('üéµ 30-Layer Audio System Initialized');
        }

        // ÏòÅÌôî Í∞êÏ†ïÏùÑ 30Í∞ú Î†àÏù¥Ïñ¥Î°ú Î≥ÄÌôò
        async function playMovieEmotion(movie) {
            if (!audioInitialized) await initAudio();
            
            const textures = movie.textures;
            const now = Tone.now();
            const duration = 4;
            
            console.log(`üéµ Playing ${movie.title} with texture layers:`);
            
            Object.entries(textures).forEach(([textureName, intensity], index) => {
                if (intensity > 0.1 && textureSynths[textureName]) {
                    playTextureLayer(textureName, intensity, now, duration, index);
                }
            });
        }

        // Í∞úÎ≥Ñ ÌÖçÏä§Ï≤ò Î†àÏù¥Ïñ¥ Ïû¨ÏÉù
        function playTextureLayer(textureName, intensity, startTime, duration, index) {
            const synth = textureSynths[textureName];
            if (!synth) return;
            
            const volume = -50 + (intensity * 35);
            if (synth.volume) synth.volume.value = volume;
            
            const delay = (index * 0.1) % 1.5;
            const actualStart = startTime + delay;
            const config = getTextureConfig(textureName, intensity);
            
            try {
                if (['density', 'warmth', 'opacity'].includes(textureName)) {
                    const chord = config.chord || ['C4', 'E4', 'G4'];
                    synth.triggerAttackRelease(chord, config.duration, actualStart);
                } else if (textureName === 'rhythm') {
                    for (let i = 0; i < 8; i++) {
                        synth.triggerAttackRelease(config.frequency, '8n', actualStart + i * 0.25);
                    }
                } else {
                    synth.triggerAttackRelease(config.frequency, config.duration, actualStart);
                }
                console.log(`  üé∂ ${textureName}: ${(intensity * 100).toFixed(0)}%`);
            } catch (error) {
                console.warn(`ÌÖçÏä§Ï≤ò ${textureName} Ïû¨ÏÉù Ïã§Ìå®:`, error);
            }
        }

        // ÌÖçÏä§Ï≤òÎ≥Ñ ÏÑ§Ï†ï
        function getTextureConfig(textureName, intensity) {
            const configs = {
                heaviness: { frequency: 55 + intensity * 55, duration: '2n' },
                lightness: { frequency: 800 + intensity * 800, duration: '4n' },
                density: { chord: ['C3', 'E3', 'G3', 'C4'], duration: '2n' },
                warmth: { chord: ['C4', 'E4', 'G4'], duration: '2n' },
                coldness: { frequency: 220 + intensity * 110, duration: '2n' },
                chaos: { frequency: 'C4', duration: '4n' },
                darkness: { frequency: 55 + intensity * 110, duration: '2n' },
                luminosity: { frequency: 880 + intensity * 880, duration: '4n' }
            };
            return configs[textureName] || { frequency: 'C4', duration: '4n' };
        }

        // Ï¥àÍ∏∞Ìôî
        async function init() {
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.set(0, 0, 1000);

            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 1, 10000);

            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: false,
                powerPreference: "high-performance"
            });

            // ÏôÑÏ†ÑÌïú ÌíÄÏä§ÌÅ¨Î¶∞ ÏÑ§Ï†ï
            const canvas = renderer.domElement;
            canvas.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
                max-width: 100vw !important;
                max-height: 100vh !important;
                margin: 0 !important;
                padding: 0 !important;
                border: none !important;
                outline: none !important;
                display: block !important;
                z-index: 1 !important;
                object-fit: cover !important;
            `;

            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000, 1);

            document.body.appendChild(canvas);

            // bodyÎèÑ Í∞ïÏ†úÎ°ú ÌíÄÏä§ÌÅ¨Î¶∞
            document.body.style.cssText = `
                width: 100vw !important;
                height: 100vh !important;
                margin: 0 !important;
                padding: 0 !important;
                overflow: hidden !important;
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                background: #000000 !important;
            `;

            const loadedMovieData = await loadMovieData();
            movieData.length = 0;
            movieData.push(...loadedMovieData);

            setupControls();
            createStars();
            createMovieParticles();

            document.addEventListener('click', onMouseClick, false);
            window.addEventListener('resize', onWindowResize, false);

            animate();
            console.log(`üåå 3D Movie Universe initialized with ${movieData.length} movies`);
        }

        // Ïª®Ìä∏Î°§ ÏÑ§Ï†ï
        function setupControls() {
            let isMouseDown = false;
            let mouseDownPosition = { x: 0, y: 0 };
            let cameraTarget = new THREE.Vector3(0, 0, 0);
            
            renderer.domElement.addEventListener('mousedown', (event) => {
                isMouseDown = true;
                mouseDownPosition.x = event.clientX;
                mouseDownPosition.y = event.clientY;
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isMouseDown = false;
            });

            renderer.domElement.addEventListener('mousemove', (event) => {
                if (isMouseDown && !autoRotate) {
                    const deltaX = event.clientX - mouseDownPosition.x;
                    const deltaY = event.clientY - mouseDownPosition.y;
                    
                    const spherical = new THREE.Spherical();
                    spherical.setFromVector3(camera.position.clone().sub(cameraTarget));
                    
                    spherical.theta -= deltaX * 0.01;
                    spherical.phi += deltaY * 0.01;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                    
                    camera.position.setFromSpherical(spherical).add(cameraTarget);
                    camera.lookAt(cameraTarget);
                    
                    mouseDownPosition.x = event.clientX;
                    mouseDownPosition.y = event.clientY;
                }
            });

            renderer.domElement.addEventListener('wheel', (event) => {
                event.preventDefault();
                const zoomSpeed = 0.1;
                const direction = camera.position.clone().sub(cameraTarget).normalize();
                
                if (event.deltaY > 0) {
                    camera.position.add(direction.multiplyScalar(100 * zoomSpeed));
                } else {
                    camera.position.sub(direction.multiplyScalar(100 * zoomSpeed));
                }
                
                const distance = camera.position.distanceTo(cameraTarget);
                if (distance < 50) {
                    camera.position.copy(cameraTarget).add(direction.normalize().multiplyScalar(50));
                } else if (distance > 5000) {
                    camera.position.copy(cameraTarget).add(direction.normalize().multiplyScalar(5000));
                }
            });
        }

        // Î∞∞Í≤Ω Î≥ÑÎì§ ÏÉùÏÑ±
        function createStars() {
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({ 
                color: 0xffffff, 
                size: 2,
                transparent: true,
                opacity: 0.8
            });

            const starVertices = [];
            for (let i = 0; i < 2000; i++) {
                const x = (Math.random() - 0.5) * 20000;
                const y = (Math.random() - 0.5) * 20000;
                const z = (Math.random() - 0.5) * 20000;
                starVertices.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        // ÏòÅÌôî ÌååÌã∞ÌÅ¥ ÌÅ¥Îü¨Ïä§ÌÑ∞ ÏÉùÏÑ± (2000Í∞ú ÏòÅÌôî Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò)
        function createMovieParticles() {
            movieData.forEach((movie, index) => {
                const t = movie.textures;

                // 3D Í≥µÍ∞Ñ Îß§Ìïë: X=Îî∞ÎúªÌï®, Y=Î¨¥Í≤åÍ∞ê, Z=Î∞ùÍ∏∞
                const centerX = (t.warmth - t.coldness) * 2000;
                const centerY = (t.heaviness - t.lightness) * 2000;
                const centerZ = (t.luminosity - t.darkness) * 2000;

                const color = getMovieColor(t);

                // Í∞Å ÏòÅÌôîÎßàÎã§ ÌååÌã∞ÌÅ¥ ÌÅ¥Îü¨Ïä§ÌÑ∞ ÏÉùÏÑ±
                const clusterSize = Math.floor(20 + (t.density || 0.5) * 80); // 20-100Í∞ú ÌååÌã∞ÌÅ¥
                const clusterRadius = 50 + (t.chaos || 0.5) * 150; // ÌÅ¥Îü¨Ïä§ÌÑ∞ Î∞òÍ≤Ω

                const movieCluster = new THREE.Group();
                movieCluster.position.set(centerX, centerY, centerZ);

                // ÌÅ¥Îü¨Ïä§ÌÑ∞ ÎÇ¥ Í∞úÎ≥Ñ ÌååÌã∞ÌÅ¥Îì§ ÏÉùÏÑ±
                for (let i = 0; i < clusterSize; i++) {
                    // Íµ¨Ìòï Î∂ÑÌè¨Î°ú ÌååÌã∞ÌÅ¥ Î∞∞Ïπò
                    const phi = Math.acos(2 * Math.random() - 1);
                    const theta = 2 * Math.PI * Math.random();
                    const radius = Math.pow(Math.random(), 0.5) * clusterRadius;

                    const x = radius * Math.sin(phi) * Math.cos(theta);
                    const y = radius * Math.sin(phi) * Math.sin(theta);
                    const z = radius * Math.cos(phi);

                    // ÌååÌã∞ÌÅ¥ ÌÅ¨Í∏∞ÏôÄ Ìà¨Î™ÖÎèÑ Î≥ÄÌôî
                    const particleSize = 1 + Math.random() * 4;
                    const opacity = 0.3 + Math.random() * 0.7;

                    const geometry = new THREE.SphereGeometry(particleSize, 8, 6);
                    const material = new THREE.MeshBasicMaterial({
                        color: color.clone().multiplyScalar(0.8 + Math.random() * 0.4),
                        transparent: true,
                        opacity: opacity * (t.opacity || 0.7),
                        wireframe: false
                    });

                    const particle = new THREE.Mesh(geometry, material);
                    particle.position.set(x, y, z);

                    // Í∞úÎ≥Ñ ÌååÌã∞ÌÅ¥ Ïï†ÎãàÎ©îÏù¥ÏÖò Îç∞Ïù¥ÌÑ∞
                    particle.userData = {
                        rotationSpeed: {
                            x: (Math.random() - 0.5) * 0.02,
                            y: (Math.random() - 0.5) * 0.02,
                            z: (Math.random() - 0.5) * 0.02
                        },
                        floatOffset: Math.random() * Math.PI * 2,
                        floatSpeed: 0.5 + Math.random() * 1.5
                    };

                    movieCluster.add(particle);
                }

                // ÌÅ¥Îü¨Ïä§ÌÑ∞ Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞
                movieCluster.userData = {
                    movie: movie,
                    rotationSpeed: {
                        x: (t.pulsing - 0.5) * 0.01,
                        y: (t.flowing - 0.5) * 0.01,
                        z: (t.rhythm - 0.5) * 0.01
                    },
                    floatOffset: Math.random() * Math.PI * 2,
                    originalPosition: { x: centerX, y: centerY, z: centerZ },
                    isCluster: true
                };

                scene.add(movieCluster);
                movieParticles.push(movieCluster);
            });

            console.log(`‚úÖ Created ${movieParticles.length} movie particle clusters in 3D space`);
        }

        // Í∞êÏ†ï Í∏∞Î∞ò ÏÉâÏÉÅ Í≤∞Ï†ï (30Í∞ú ÌÖçÏä§Ï≤ò Í∏∞Î∞ò)
        function getMovieColor(textures) {
            const { warmth, coldness, luminosity, darkness, burning, freezing } = textures;

            // Îî∞ÎúªÌï®Í≥º Ï∞®Í∞ÄÏõÄÏùò Í∑†Ìòï
            if (warmth > 0.7 && burning > 0.6) return new THREE.Color(0xff6b35); // Îú®Í±∞Ïö¥ Ï£ºÌô©ÏÉâ
            else if (warmth > 0.6) return new THREE.Color(0xf1c40f); // Îî∞ÎúªÌïú ÎÖ∏ÎûÄÏÉâ
            else if (coldness > 0.7 && freezing > 0.6) return new THREE.Color(0x3498db); // Ï∞®Í∞ÄÏö¥ ÌååÎûÄÏÉâ
            else if (coldness > 0.6) return new THREE.Color(0x4a90e2); // ÏãúÏõêÌïú ÌååÎûÄÏÉâ

            // Î∞ùÍ∏∞ÏôÄ Ïñ¥Îë†Ïùò Í∑†Ìòï
            else if (luminosity > 0.7) return new THREE.Color(0xe74c3c); // Î∞ùÏùÄ Îπ®Í∞ÑÏÉâ
            else if (darkness > 0.7) return new THREE.Color(0x2c3e50); // Ïñ¥ÎëêÏö¥ ÌöåÏÉâ
            else if (luminosity > 0.5) return new THREE.Color(0x9b59b6); // Î≥¥ÎùºÏÉâ
            else if (darkness > 0.5) return new THREE.Color(0x34495e); // ÏßÑÌïú ÌöåÏÉâ

            else return new THREE.Color(0x95a5a6); // Ï§ëÏÑ± ÌöåÏÉâ
        }

        // ÌÅ¥Î¶≠ Ìï∏Îì§Îü¨
        function onMouseClick(event) {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);

            // ÌÅ¥Îü¨Ïä§ÌÑ∞Ïùò Î™®Îì† ÏûêÏãù ÌååÌã∞ÌÅ¥Îì§ÏùÑ ÎåÄÏÉÅÏúºÎ°ú Î†àÏù¥Ï∫êÏä§ÌåÖ
            const allParticles = [];
            movieParticles.forEach(cluster => {
                cluster.children.forEach(particle => {
                    particle.parentCluster = cluster; // Î∂ÄÎ™® ÌÅ¥Îü¨Ïä§ÌÑ∞ Ï∞∏Ï°∞ Ï†ÄÏû•
                    allParticles.push(particle);
                });
            });

            const intersects = raycaster.intersectObjects(allParticles);

            if (intersects.length > 0) {
                const intersectedParticle = intersects[0].object;
                const parentCluster = intersectedParticle.parentCluster;
                clickCount++;
                
                if (clickTimeout) clearTimeout(clickTimeout);
                
                clickTimeout = setTimeout(() => {
                    if (clickCount === 1) {
                        handleSingleClick(parentCluster);
                    } else if (clickCount === 2) {
                        handleDoubleClick(parentCluster);
                    }
                    clickCount = 0;
                }, 300);
            }
        }

        async function handleSingleClick(cluster) {
            const movie = cluster.userData.movie;

            // Ï≤´ ÌÅ¥Î¶≠ Ïãú Ïò§ÎîîÏò§ Ï¥àÍ∏∞Ìôî
            if (!audioInitialized) {
                console.log('üéµ Initializing audio on first click...');
                await initAudio();
            }

            await playMovieEmotion(movie);
            highlightCluster(cluster);
            console.log(`üéµ Playing: ${movie.title}`);
        }

        function handleDoubleClick(cluster) {
            const movie = cluster.userData.movie;
            showMovieInfo(movie);
            zoomToCluster(cluster);
            console.log(`üéØ Focusing on: ${movie.title}`);
        }

        function zoomToCluster(cluster) {
            const pos = cluster.position;
            const distance = 300; // ÌÅ¥Îü¨Ïä§ÌÑ∞Îäî Îçî ÌÅ∞ Í±∞Î¶¨ÏóêÏÑú Î≥¥Í∏∞
            const direction = new THREE.Vector3().subVectors(camera.position, pos).normalize();
            const targetPosition = new THREE.Vector3().copy(pos).add(direction.multiplyScalar(distance));
            animateCamera(targetPosition, pos);
        }

        function animateCamera(targetPosition, lookAtTarget) {
            const startPosition = camera.position.clone();
            let progress = 0;
            const duration = 1500;
            
            function animate() {
                progress += 16;
                const t = Math.min(progress / duration, 1);
                const easeT = t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
                
                camera.position.lerpVectors(startPosition, targetPosition, easeT);
                camera.lookAt(lookAtTarget);
                
                if (t < 1) requestAnimationFrame(animate);
            }
            animate();
        }

        function showMovieInfo(movie) {
            const info = document.getElementById("movieInfo");
            document.getElementById("movieTitle").textContent = movie.title;
            document.getElementById("movieDetails").textContent =
                `${movie.director} | ${movie.country} ${movie.year} | ${movie.genres.join(", ")} | ‚≠ê ${movie.vote_average}`;
            document.getElementById("movieMessage").textContent = movie.core_message;

            const t = movie.textures;
            document.getElementById("emotionProfile").innerHTML = `
                <div style="margin-top: 10px; font-size: 11px;">
                    <div>üå°Ô∏è Warmth: ${(t.warmth * 100).toFixed(0)}% | ‚ùÑÔ∏è Coldness: ${(t.coldness * 100).toFixed(0)}%</div>
                    <div>‚öñÔ∏è Heaviness: ${(t.heaviness * 100).toFixed(0)}% | ü™∂ Lightness: ${(t.lightness * 100).toFixed(0)}%</div>
                    <div>üí° Luminosity: ${(t.luminosity * 100).toFixed(0)}% | üåë Darkness: ${(t.darkness * 100).toFixed(0)}%</div>
                    <div>üåÄ Chaos: ${(t.chaos * 100).toFixed(0)}% | üéµ Rhythm: ${(t.rhythm * 100).toFixed(0)}%</div>
                </div>
            `;

            info.classList.add("visible");
            setTimeout(() => info.classList.remove("visible"), 10000);
        }

        function highlightCluster(cluster) {
            // Ïù¥Ï†Ñ ÌÅ¥Îü¨Ïä§ÌÑ∞ ÌïòÏù¥ÎùºÏù¥Ìä∏ Ï†úÍ±∞
            if (currentlyPlaying) {
                currentlyPlaying.children.forEach(particle => {
                    particle.material.emissive.setHex(0x000000);
                });
            }

            // ÏÉà ÌÅ¥Îü¨Ïä§ÌÑ∞ ÌïòÏù¥ÎùºÏù¥Ìä∏
            cluster.children.forEach(particle => {
                particle.material.emissive.setHex(0x444444);
            });

            currentlyPlaying = cluster;
            setTimeout(() => {
                cluster.children.forEach(particle => {
                    particle.material.emissive.setHex(0x000000);
                });
                if (currentlyPlaying === cluster) currentlyPlaying = null;
            }, 3000);
        }

        // Ïï†ÎãàÎ©îÏù¥ÏÖò Î£®ÌîÑ
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            if (isAnimating) {
                if (autoRotate) {
                    camera.position.x = Math.cos(time * 0.1) * 1500;
                    camera.position.z = Math.sin(time * 0.1) * 1500;
                    camera.lookAt(new THREE.Vector3(0, 0, 0));
                }
                
                movieParticles.forEach(cluster => {
                    const userData = cluster.userData;

                    // ÌÅ¥Îü¨Ïä§ÌÑ∞ Ï†ÑÏ≤¥ ÌöåÏ†Ñ
                    cluster.rotation.x += userData.rotationSpeed.x;
                    cluster.rotation.y += userData.rotationSpeed.y;
                    cluster.rotation.z += userData.rotationSpeed.z;

                    // ÌÅ¥Îü¨Ïä§ÌÑ∞ Ï†ÑÏ≤¥ Î∂ÄÏú† ÏõÄÏßÅÏûÑ
                    const floatY = Math.sin(time + userData.floatOffset) * 30;
                    const floatX = Math.cos(time * 0.7 + userData.floatOffset) * 15;
                    const floatZ = Math.sin(time * 0.5 + userData.floatOffset) * 20;

                    cluster.position.x = userData.originalPosition.x + floatX;
                    cluster.position.y = userData.originalPosition.y + floatY;
                    cluster.position.z = userData.originalPosition.z + floatZ;

                    // ÌÅ¥Îü¨Ïä§ÌÑ∞ ÎÇ¥ Í∞úÎ≥Ñ ÌååÌã∞ÌÅ¥ Ïï†ÎãàÎ©îÏù¥ÏÖò
                    cluster.children.forEach(particle => {
                        const particleData = particle.userData;
                        particle.rotation.x += particleData.rotationSpeed.x;
                        particle.rotation.y += particleData.rotationSpeed.y;
                        particle.rotation.z += particleData.rotationSpeed.z;

                        // Í∞úÎ≥Ñ ÌååÌã∞ÌÅ¥Ïùò ÎØ∏ÏÑ∏Ìïú ÏõÄÏßÅÏûÑ
                        const microFloat = Math.sin(time * particleData.floatSpeed + particleData.floatOffset) * 2;
                        particle.position.y += microFloat * 0.1;
                    });
                });
            }
            
            renderer.render(scene, camera);
        }

        // Ïª®Ìä∏Î°§ Ìï®ÏàòÎì§
        function resetCamera() {
            camera.position.set(0, 0, 1000);
            camera.lookAt(new THREE.Vector3(0, 0, 0));
        }

        function randomFocus() {
            const randomCluster = movieParticles[Math.floor(Math.random() * movieParticles.length)];
            const pos = randomCluster.position;
            camera.position.set(pos.x + 500, pos.y + 300, pos.z + 500);
            camera.lookAt(pos);
            showMovieInfo(randomCluster.userData.movie);
        }

        function toggleAnimation() {
            isAnimating = !isAnimating;
            const btn = document.querySelector('.controls button:nth-child(3)');
            btn.textContent = isAnimating ? '‚è∏Ô∏è Animation' : '‚ñ∂Ô∏è Animation';
        }

        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            const btn = document.querySelector('.controls button:nth-child(4)');
            btn.textContent = autoRotate ? '‚èπÔ∏è Auto Rotate' : 'üîÑ Auto Rotate';
        }

        function updateSpeed(value) {
            speed = parseInt(value);
            document.getElementById('speedValue').textContent = speed;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // Ï∫îÎ≤ÑÏä§ Ïä§ÌÉÄÏùºÎèÑ Îã§Ïãú ÏÑ§Ï†ï
            renderer.domElement.style.width = '100vw';
            renderer.domElement.style.height = '100vh';
        }

        // ÏãúÏûë!
        init();
    </script>
</body>
</html>